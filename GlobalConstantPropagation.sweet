public void SpecializeFuncts() {
case MILProgram {
	    /** TODO comment
		*/

        for (DefnSCCs dsccs = sccs; dsccs!=null; dsccs=dsccs.next) {
    //      for (Defns ds=dsccs.head.getBindings(); ds!=null; ds=ds.next) {
    //        ds.head.cleanup();
    //      }
//          for (Defns ds=dsccs.head.getBindings(); ds!=null; ds=ds.next) {
 //           ds.head.detectLoops(null);
 //         }
          for (Defns ds=dsccs.head.getBindings(); ds!=null; ds=ds.next) {
    //!System.out.println("inlining loop at: " + ds.head.getId());
        	  
          	// TODO
        	// Args: 3 for max number of different known specializations for a particular arg
        	//			for the case of arrs.mini, it does not seem to make a difference
        	//		false because if this parameter is true it introduces a bug
       	
            ds.head.buildLattice(1, false);

          }
        }
      }

MILProgram {
         cfunSimplify();
     
         count = 1;

        int lastcount = 0;
        int bothcounts = 1;
        for (int j=0; j<20 && bothcounts > 0; j++) {
	        //count = 1;
	        for (int i=0; i<20 && count>0; i++) {
	          debug.Log.println("-------------------------");
	    //!System.out.println("==================================================");
	    //!System.out.println("Step " + i);
	    //!System.out.println("==================================================");
	    //!display();
	    //!System.out.println("==================================================");
	          count = 0;
	          inlining();
	          debug.Log.println("Inlining pass finished, running shake.");
	          shake();
	          liftAllocators();  // TODO: Is this the right position for liftAllocators?
	          flow();
	          debug.Log.println("Flow pass finished, running shake.");
	          shake();
	          debug.Log.println("Steps performed = " + count);
	          lastcount = count;
	          }
	        //break;
	        bothcounts = lastcount;
	        count = 1;
	        for (int k=0; k<20 && count>0; k++) {
	        	count = 0;
	        	SpecializeFuncts();
		        debug.Log.println("SpecializeFuncts pass finished, running shake.");
	        	shake();
	            debug.Log.println("Steps performed = " + count);
	        	//display();
	        	lastcount = count;
	        }
	        bothcounts += lastcount;
	        count = lastcount;
         }
    }
	public abstract class Defn {
		// A block: b(formals) = code ----------------------------------
		public case Block(private Code code) {
			/*private static int count = 0;
			private final String id = "b" + count++;
			private Var[] formals; // filled in after construction by analysis
			setter formals;*/
			private Blocks children;
			private Atom replacedVar;
			private Blocks derived;
			private int version;
		}

    public void buildLattice(int maxArgReplacement, boolean unrollLoops)
	case Defn abstract;
	case ClosureDefn {
		// TODO: Implement this, only sibling class that it is implemented is Block.java
    	System.out.println("reached ClosureDefn buildLattice of block" + id);
    }
	case TopLevel {
		// TODO: Implement this, only sibling class that it is implemented is Block.java
    	System.out.println("reached TopLevel buildLattice of block" + id);
    }
	
    case Block
    	//TODO
    	if (formals.length == 0) {
    	//	System.out.println("Block " + id + " has no vars");
    		return;
    	}
    	if (version > 3) {
    		System.out.println("Block " + id + " is version " + version);
    		
			return;
	
    	}
    	//System.out.println("reached Block buildLattice of block " + id);
   
    	Atom knownArgs[][] = new Atom[formals.length][maxArgReplacement];
    	
    	
    	for(Defns xs= this.getCallers(); xs != null; xs = xs.next)
    	{
    		Block x = (Block) xs.head;

    		BlockCalls x_calls = x.code.getBlockCall(id);
    		if (x_calls != null)
    		{
    			BlockCalls current_call = x_calls;
    			
    			while (current_call != null) {
    				
    				// Check for calls from the current block
    				if (x.getId().equalsIgnoreCase(id))
    				{
    					//x_calls.head.args;
        				Atom reEntryFormals[] = checkArguments();
        				for (int j = 0; j < formals.length; ++j )
        				{
        					if (knownArgs[j][0] != Atom.CAtom.NAC)
        						
        					{
        						// TODO: is it ever valid to not replace it with NAC?
        						if (!unrollLoops && reEntryFormals[j] ==  Atom.CAtom.NAC)
        							knownArgs[j][0] =  Atom.CAtom.NAC;
        						if ((reEntryFormals[j].isConst() != null))
        						{
        							int k;
        						
	        						for (k = 0; k < maxArgReplacement; ++k)
	        						{
	        							if (knownArgs[j][k] == null) {
	        								knownArgs[j][k] = reEntryFormals[j];
	        								break;
	        							}
	        							if (reEntryFormals[j].sameAtom(knownArgs[j][k])) {
	        								break;
	        							}
	        						}
	        						if (k == maxArgReplacement) {
	        							knownArgs[j][0] = Atom.CAtom.NAC;
	        						}
        						}
        					}
        				}
        			
    					//x_calls.head.display();
        				
        			//	System.out.println("Block " + id + " called from itself");
        			
        			//Atom a[] modifies;
        			
        			}
    				else {
    					Atom formals2[] =  current_call.head.args;
    					for (int j = 0; j < formals.length; ++j )
        				{
        					if (knownArgs[j][0] !=  Atom.CAtom.NAC && (formals2[j].isConst() != null))
        					{
        						int k;
        						for (k = 0; k < maxArgReplacement; ++k)
        						{
        							if (knownArgs[j][k] == null) {
        								knownArgs[j][k] =  formals2[j];
        								break;
        							}
        							if (formals2[j].sameAtom(knownArgs[j][k])) {
        								break;
        							}
        						}
        						if (k == maxArgReplacement) {
        							knownArgs[j][0] =  Atom.CAtom.NAC;
        						}
        					}
        				}
    				}
    				current_call = current_call.next;
        		}
    		}
    	}
    		
		//System.out.println(id + "Found constants");
		int newVersion = version+1;
		for (int j = 0; j < formals.length; ++j )
		{
			if (knownArgs[j][0] == Atom.CAtom.NAC || knownArgs[j][0] == Atom.CAtom.UNDEF) {
				//System.out.println("Arg " + j + " is " + knownArgs[j][0].toString());
				continue;
			}
			for ( int k = 0; k < maxArgReplacement; ++k) {
				if (knownArgs[j][k] != null) {
					Block b = null;
					Blocks currentChild = this.children;
					while (currentChild != null) {
						if (currentChild.head.replacedVar.sameAtom(knownArgs[j][k]))
						{
							b = currentChild.head;
							break;
						}
						currentChild = currentChild.next;
					}
					if (b == null ) {
						b = new Block();
						b.version = newVersion++;
					    derived   = new Blocks(b, derived);
					    int l = formals.length -1;
					    Var[] nfs = new Var[l];
					    for (int i = 0; i < l; ++i) {
					    	if (i >= j)
					    	{
					    		nfs[i] = formals[i+1];
					    	}
					    	else
					    		nfs[i] = formals[i];
					    		
					    }
					   // Code bind = new Bind(formals[j], new Return(knownArgs[j][k]), code);
					    //b.code = bind;
						b.code = code.copy();
					    b.formals = nfs;
					    b.replacedVar = knownArgs[j][k];				    
					    b.code.replaceCalls(id, j, formals[j], b);
					    b.code = b.code.apply(new AtomSubst(formals[j], knownArgs[j][k], null));
					    children = new Blocks(b, children);
					    
						//defns.
						System.out.println("Created Block " + b.id + "from block " + id);
						count++;
						//b.display();
					}
				    //new BlockCall(b);
				    //BlockCalls foo = 
	
		        	for(Defns xs1= this.getCallers(); xs1 != null; xs1 = xs1.next)
		        	{
		        		Block x1 = (Block) xs1.head;
		        		if (x1.code.replaceCalls(id, j, knownArgs[j][k], b))
		        		{
		        			//TODO is it necessary to update call(er/ee)s
		        			//b.
		        			count++;
		        		}
		        		//BlockCalls x_calls = x.code.getBlockCall(id);
		        		//if (x_calls.)
		        	}
	
		    		
					//System.out.println(lattice[j][k].toString());
				}
				//else
			}
		}
		//x.displayDefn();
		//for (Vars v = x.getLiveVars(); v != null; v = v.next)
		//	System.out.println("Live + " + v.head.toString());
	

    }
    private  Atom [] checkArguments() {
    	Atom [] arguments = new Atom[formals.length];
     	for (int i = 0; i < formals.length; ++i)
     		arguments[i] = formals[i];
     	BlockCalls bc = code.getBlockCall(id);
     	while (bc != null) {
         	for (int i = 0; i < arguments.length; ++i)
         	{
         		Atom a = bc.head.args[i];
         		if (!arguments[i].sameAtom(a)) {
         			if (a.isConst() != null) {
         				arguments[i] = a;
         			}
         			else {
         				arguments[i] = Atom.CAtom.NAC;
         			}
	
         		}
         	}
         	bc = bc.next;
     	}
     	arguments = code.checkformals(arguments);
    	for (int i = 0; i < formals.length; ++i)
    	{
    		if (arguments[i] == null) break;
    		if (arguments[i] != Atom.CAtom.NAC) {
    			if (arguments[i].isConst() != null &&  !arguments[i].sameAtom(formals[i])) {
    				arguments[i] = Atom.CAtom.NAC;
    			}
    			//if (formals2[i].isVar) {
    			//	System.out.println(formals2[i].isConst());
    			//}
    			//else {
    				
    			//	formals2[i] = Var.empty.EMPTY;
    			//	System.out.println("Argument " + i + " is not a constant, ignoring");
    			//}
    		}
    		else {
    			// TODO
    			System.out.println("Argument " + i + " is modified");
    			
    		}
    	}
    	return arguments;

		
	}
    public void replaceBc(BlockCall bc)
	case TAlt { this.bc = bc; }

boolean callsBlock(String id)
case BlockCall
    {
    	if (b == null) return false;
    	return b.getId().equalsIgnoreCase(id);
    }

	macro List(BlockCall) // Introduces class BlockCalls

	public abstract class Atom
	public case static class CAtom(private final String identifier) {
			public static final CAtom NAC = new CAtom("Not a constant");
			public static final CAtom UNDEF = new CAtom("undefined");
	}
//	@Override
	public String toString() !
	case CAtom	{ return identifier; }
//	@Override
	public Val lookup(ValEnv env) throws Fail !
		case CAtom	{ throw new Fail("lookup called on " + identifier); }

	@Override
	public BlockCalls getBlockCall(String id) !
	case Code {return null;}
	case Bind {
		BlockCall thisCall = null;
		BlockCall bc = t.isBlockCall();
		if (bc instanceof BlockCall)
		{
			// TODO is this ever needed
			if (bc.callsBlock(id)) {
				thisCall = bc;
			}
		}
		BlockCalls calls = c.getBlockCall(id);
		if (thisCall != null)
			calls = new BlockCalls(thisCall, calls);
		
		return calls;
	}
	case Done {
		BlockCall thisCall = null;
		BlockCall bc = t.isBlockCall();
		if (bc != null)
		{
			// TODO is this ever needed
			if (bc.callsBlock(id)) {
				thisCall = bc;
			}
		}
		BlockCalls calls = null;
		if (thisCall != null)
			calls = new BlockCalls(thisCall, calls);
		
		return calls;
	}
	case TAlt { 
		if (bc != null && bc.callsBlock(id))
    		return bc;
    	return null;
    }


	public Atom[] checkformals(Atom[] atoms)
	case Code { return atoms; }
	case Bind { for(int i = 0; i < atoms.length; ++i) {
			if (v.sameAtom(atoms[i])) {
				atoms[i] = Atom.CAtom.NAC;
			}
		}
		return c.checkformals(atoms);
		
	}
	case Match {
		BlockCalls block_calls = null;
		if (def!=null) {
			if (def.callsBlock(id)) {
				block_calls = new BlockCalls(def, block_calls);
            //	Atom args[] = def.args;
            //	for(Atom a : args)
    		//		System.out.println(a.toString());
			}
		}

        for (int i=0; i<alts.length; i++) {
            BlockCall alt_blockCall = alts[i].getBlockCall(id);
            if (alt_blockCall != null && alt_blockCall.callsBlock(id))
            {
				block_calls = new BlockCalls(alt_blockCall, block_calls);
            }
          }
		return block_calls;
	}

	boolean replaceCalls(String id, int j, Atom replaced, Block b)
	case Code { return false; }
	case Bind {
		Boolean success = false;
		BlockCall thisCall = null;
		BlockCall bc = t.isBlockCall();
		if (bc != null)
		{
			// TODO is this ever needed
			if (bc.callsBlock(id)) {
				thisCall = bc;
				if (thisCall.args[j].sameAtom(replaced)) {
					
					BlockCall temp = new BlockCall(b);
					int l = bc.args.length-1;
					temp.args = new Atom[l];
				    for (int i = 0; i < l; ++i) {
				    	if (i >= j)
				    	{
				    		temp.args[i] = bc.args[i+1];
				    	}
				    	else
				    		temp.args[i] = bc.args[i];
				    }
				    t = temp;
				    success = true;
				}
			}
			
		}
		
		return c.replaceCalls(id, j, replaced, b) || success;
	}
	case Done {
		BlockCall thisCall = null;
		BlockCall bc = t.isBlockCall();
		if (bc != null)
		{
			if (bc.callsBlock(id)) {
				thisCall = bc;
				if (thisCall.args[j].sameAtom(replaced)) {
					
					BlockCall temp = new BlockCall(b);
					int l = bc.args.length-1;
					temp.args = new Atom[l];
				    for (int i = 0; i < l; ++i) {
				    	if (i >= j)
				    	{
				    		temp.args[i] = bc.args[i+1];
				    	}
				    	else
				    		temp.args[i] = bc.args[i];
				    }
				    t = temp;
				    return true;
				}
			}
		}
		return false;
	}
	case Match {
		boolean success = false;
		if (def!=null) {
		// Determine if the default case is a call to block id
			if (def.callsBlock(id)) {

				// Compare to either see if the call to block id can be replaced with a call to block b
				if (def.args[j].sameAtom(replaced)) {
					
					BlockCall temp = new BlockCall(b);
					int l = def.args.length-1;
					temp.args = new Atom[l];
				    for (int i = 0; i < l; ++i) {
				    	if (i >= j)
				    	{
				    		temp.args[i] = def.args[i+1];
				    	}
				    	else
				    		temp.args[i] = def.args[i];
				    }
				    def = temp;
				    success = true;
				}
			}

		}

        for (int i=0; i<alts.length; i++) {
            BlockCall alt_blockCall = alts[i].getBlockCall(id);
            if (alt_blockCall != null && alt_blockCall.callsBlock(id)){
				if (alt_blockCall.args[j].sameAtom(replaced)) {
					
					BlockCall temp = new BlockCall(b);
					int l = alt_blockCall.args.length-1;
					temp.args = new Atom[l];
				    for (int i1 = 0; i1 < l; ++i1) {
				    	if (i1 >= j)
				    	{
				    		temp.args[i1] = alt_blockCall.args[i1+1];
				    	}
				    	else
				    		temp.args[i1] = alt_blockCall.args[i1];
				    }
				    alts[i].replaceBc(temp);
				    success = true;
				}
			}
          }
        return success;
	}
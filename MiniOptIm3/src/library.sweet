/*@
%------------------------------------------------------------------------------
\chapter{Library Operations}\label{sec-appendix-library}
%------------------------------------------------------------------------------
This appendix provides some general purpose data structures and algorithmic
tools, each of which is packaged using one ore more sweet macros.  Each of
these components is used, often multiple times, in the main code but we have
chosen to present them separately because they they are not in any way specific
to the languages that we are working with in the rest of this document.

@*/
/*@
%==============================================================================
\section{Singleton Classes}
%==============================================================================

@*/
macro Singleton(Class) {
  class Class {
    private Class() {}
    public static final Class obj = new Class();
  }
}

/*@
%==============================================================================
\section{Caching}
%==============================================================================

@*/
macro Cache(Type, name, cache, arg) {
  private static Type[] cache = new Type[10];
  public static Type name(int arg) {
    if (arg>=cache.length) {
      Type[] newCache = new Type[Math.max(arg+1, 2*cache.length)];
      for (int i=0; i<cache.length; i++) {
        newCache[i] = cache[i];
      }
      cache = newCache;
    } else if (cache[arg]!=null) {
      return cache[arg];
    }
    // Code to update cache[arg] = ... will be appended here.
  }
  // A questionable use of sweet macros; we require the instantiation of this
  // macro to be followed by > { code } where code calculates and returns a
  // value to be cached in cache[arg].
  Type name(int arg)
}

/*@
%==============================================================================
\section{Simple List Operations}
%==============================================================================

@*/ 
/** This macro can be used to define a simple linked list of values.
 */
macro List(X) {
  public class X\s(public X head, public X\s next)
}

/*@
This macro can be used to place a reverse method in any class
that has a basic "linked-list" structure.  The first parameter
specifies the name of the class, while the second is the name
of the field that holds a pointer to the next list element.
The reverse method generated by this code is a static and
destructive implementation of list reverse.

@*/ 
macro AddReverse(Xs) {
  class Xs { 
    /** Reverse a linked list of elements.
     */
    public static Xs reverse(Xs list) {
      Xs result = null;
      while (list!=null) {
        Xs temp = list.next;
        list.next   = result;
        result      = list;
        list        = temp;
      }
      return result;
    }
  }
}

/*@
The next macro can be used to place a length method in any class
that has a basic ``linked-list'' structure.  The first parameter
specifies the name of the class, while the second is the name
of the field that holds a pointer to the next list element.
The length method generated by this code is static.

@*/ 
macro AddLength(Xs) {
    class Xs { 
        /** Return the length of a linked list of elements.
         */
        public static int length(Xs list) {
            int len = 0;
            for (; list!=null; list=list.next) {
                len++;
            }
            return len;
        }
    }
}

/*@
This macro can be used to place an @isIn()@ method in any class
that has a basic ``linked-list'' structure.

@*/
macro AddIsIn(X) {
    class X\s {
        /** Test for membership in a list.
         */
        public static boolean isIn(X val, X\s list) {
            for (; list!=null; list=list.next) {
                if (list.head==val) {
                    return true;
                }
            }
            return false;
        }
    }
}

/*@
This macro can be used to place a cons method in a class that
has a basic ``linked-list'' structure.  The cons method is
added to the Elem class, and builds a new List value by
adding this element to the front of the next list.

@*/ 
macro AddCons(X) {
    class X {
        public X\s cons(X\s next) {
            return new X\s(this, next);
        }
    }
}

/*@
%==============================================================================
\section{Ordered Lists}
%==============================================================================
An ordered list is a simple linked list data structure in which each element has
a associated integer key.  The elements are stored in increasing key order with
at most one element for any given key value.  This makes it possible to implement
standard set operations---including subset and membership tests as well as union,
intersection, and difference---in linear time.

@*/
macro OrderedList(X, getN) {
  public class private X\s(private X head, private X\s next) {

    /** Determine whether x is a member of the list xs.
     */
    public static boolean member(X x, X\s xs) {
      for (int n=x.getN(); xs!=null; xs=xs.next) {
        int m = xs.head.getN();
        if (m>n)  { return false; }
        if (m==n) { return true;  }
      }
      return false;
    }

    /** Determine whether xs and ys are the same lists.
     */
    public static boolean same(X\s xs, X\s ys) {
      while (xs!=null) {
        if (ys==null || xs.head.getN()!=ys.head.getN()) {
          return false;
        }
      }
      return (ys==null);
    }

    /** Determine whether xs is a subset of ys.
     */
    public static boolean subset(X\s xs, X\s ys) {
      if (xs==null) {
        return true;
      } else {
        // Basic idea: n is the value of the head of xs, and hence
        // the first number that we will be searching for in ys.
        for (int n=xs.head.getN(); ys!=null; ys=ys.next) {
          int m = ys.head.getN();
          if (m>n) {             // n does not appear in ys
            return false;
          } else if (m==n) {     // found a match
            if ((xs = xs.next)==null) {
              return true;       // all elements of xs were matched!
            }
            n = xs.head.getN();
          }
        }
        return false;
      }
    }

    /** Insert x into the list ys.
     */
    public static X\s insert(X x, X\s ys) {
      X\s orig = ys;  // remember start of list
      X\s prev = null;
      int  n    = x.getN();
      while (ys!=null) {
        int m = ys.head.getN();
        if (m>n)  { break; }
        if (m==n) { return orig; }
        prev = ys;
        ys   = ys.next;
      }
      if (prev==null) {
        return new X\s(x, ys);
      } else {
        prev.next = new X\s(x, ys);
        return orig;
      }
    }

    /** Insert the elements of xs into the list ys.  New list nodes
     *  are created for each element of xs, even at the end of the
     *  list; we do not attempt to modify or share any portion of
     *  list structure of xs, but we are free to modify ys.
     */
    public static X\s insert(X\s xs, X\s ys) {
      X\s orig = ys;  // remember start of list

      // Loop through the elements that we want to insert
      for (X\s prev=null; xs!=null; xs=xs.next) {
        int n = xs.head.getN();
        int m = 0; // to prevent uninitialized variable warning

        // Find position in ys where we should insert u.head
        for (; ys!=null && n>(m=ys.head.getN()); ys=ys.next) {
          prev = ys;
        }

        // Insert xs.head into ys at this position (if it is not already there)
        if (ys!=null && n==m) {         // Already included?
          prev = ys;
          ys   = ys.next;
        } else {                        // Need to insert ...
          X\s next = new X\s(xs.head, ys);
          prev = (prev==null) ? (orig = next) : (prev.next = next);
        }
      }
      return orig;
    }

    /** Remove an element x from a list ys.
     */
    public static X\s remove(X x, X\s ys) {
      X\s orig = ys;  // remember start of list
      X\s prev = null;
      int  n    = x.getN();
      while (ys!=null) {
        int m = ys.head.getN();
        if (m>n) { return orig; } // element not found
        if (m==n) {
          if (prev==null) {
            return ys.next;
          } else {
            prev.next = ys.next;
            return orig;
          }
        }
        prev = ys;
        ys   = ys.next;
      }
      return orig;
    }

    /** Remove the elements of xs from the list ys.  Applies destructive
     *  updates to ys, but does not modify xs.
     */
    public static X\s remove(X\s xs, X\s ys) {
      X\s orig = ys;  // remember start of list

      // Loop through the elements that we want to remove
      for (X\s prev=null; xs!=null; xs=xs.next) {
        int n = xs.head.getN();
        int m = 0; // to prevent uninitialized variable warning

        // Find position in ys where xs.head would occur
        for (; ys!=null && n>(m=ys.head.getN()); ys=ys.next) {
          prev = ys;
        }

        if (ys==null) {    // At end of list, element not found
          return orig;
        } else if (n==m) { // Remove a matching element
          if (prev==null) {
            orig = ys.next;
          } else {
            prev.next = ys.next;
          }
          ys = ys.next;
        }
      }
      return orig;
    }

    /** Intersect xs with ys, removing elements from ys that are NOT in xs.
     */
    public static X\s intersect(X\s xs, X\s ys) {
      X\s orig = ys;  // remember start of list

      // Loop through the elements that we want to keep
      X\s prev = null;
      for (; xs!=null; xs=xs.next) {
        int n = xs.head.getN();
        int m = 0; // to prevent uninitialized variable warning

        // Remove elements from ys that don't match n
        for (; ys!=null && n>(m=ys.head.getN()); ys=ys.next) {
          if (prev==null) {
            orig = ys.next;
          } else {
            prev.next = ys.next;
          }
        }

        if (ys==null) {    // At end of list, element not found
          return orig;
        } else if (n==m) { // Keep a matching element
          prev = ys;
        }
        ys = ys.next;
      }
      // Drop remaining elements from ys
      if (prev==null) {
        return null;
      } else {
        prev.next = null;
        return orig;
      }
    }
  }
}

  /* Display this list of variables.
  public static void display(String msg, X\s ts) {
    System.out.print(msg + " =");
    for (; ts!=null; ts=ts.next) {
      System.out.print(" " + ts.head.getN());
    }
    System.out.println();
  }
   */

/*@
%==============================================================================
\section{Dependency Analysis}
%==============================================================================

The goal of a dependency analysis is to
construct a directed acyclic graph of binding groups from an input
list of bindings.  Each binding group is just a strongly-connected
component in the dependency graph, and so we will base our
implementation of dependency analysis on a standard algorithm for
computing the strongly-connected components of a directed graph.
More specifically, we will use the algorithm described by Cormen,
Leiserson and Rivest \cite{CLR}, which they credit to Kosaraju
and Sharir.  This algorithm uses two depth-first searches,
one of an input graph $G=(V,E)$ and one of its transpose $G^T$
(the graph obtained from $G$ by reversing the direction of each
edge in $E$), to identify the strongly connected components
of $G$ in $O(|V|+|E|)$ time.  Our selection of this particular
algorithm was, in fact, the primary motivation for maintaining
both @callees@ and @callers@ information in individual @X@
values.  The former provides an adjacency list representation of
the dependency graph, while the latter gives an adjacency list
representation of its transpose.

The following sections build up an implementation of the strongly
connected components algorithm, starting in Section~\ref{sec-graph}
with a description of the adjacency list structures that capture
the structure of the input graph.  During the first depth-first search,
implemented by @searchForward()@,
the input list of bindings is reordered so that the bindings are
arranged in decreasing order of finishing time.  This process is
detailed in Section~\ref{sec-forward}.  The second depth-first search,
implemented by @searchReverse()@, uses this list to generate a list
of @XSCC@ values.  The implementation of @XSCCs@ is
described in Section~\ref{sec-groups}, while the details of the
actual depth-first search are presented in Section~\ref{sec-reverse}.

%------------------------------------------------------------------------------
\subsection{Representing the Dependency Graph}\label{sec-graph}
Each @X@ includes two lists of @Xs@ called
@callees@ and @callers@, which are used to hold information
about dependencies between the bindings in a given list.
Every dependency @caller -> callee@ will show up twice:
the @caller@ will be included in @callee.callers@ while the
@callee@ will be included in @caller.callees@.

@*/
macro SCCLists(X) {
  class X {
    /** Records the successors/callees of this node.
     */
    private X\s callees = null;

    /** Records the predecessors/callers of this node.
     */
    private X\s callers = null;

    /** Update callees/callers information with dependencies.
     */
    public void calls(X\s xs) {
      for (callees=xs; xs!=null; xs=xs.next) {
        xs.head.callers = new X\s(this, xs.head.callers);
      }
    }
  }
}

/*@
%------------------------------------------------------------------------------
\subsection{The Forward Depth-First Search}\label{sec-forward}
The first depth-first search is implemented by @Xs.searchForward()@, which
iterates over the @Xs@ in a given list and calls @X.forwardVisit()@ on each
one.  The latter method continues the depth-first traversal, computing reverse
dependency information by calling @X.callers@ at appropriate points, and making
recursive calls to @X.forwardVisit()@ as necessary.  The result of the first
depth-first search is a list of bindings arranged in reverse order of finishing
times.

@*/
macro SCCForwardDFS(X) {
  class X\s {
    /** Depth-first search the forward dependency graph. Returns a list with the
     *  same Xs in reverse order of finishing times.  (In other words, the last
     *  node that we finish visiting will be the first node in the result list.)
     */
    public static X\s searchForward(X\s xs, X\s result) {
      for (; xs!=null; xs=xs.next) {
        result = xs.head.forwardVisit(result);
      }
      return result;
    }
  }

  class X {
    /** Flag to indicate that this node has been visited during the depth-first
     *  search of the forward dependency graph.
     */
    private boolean visited = false;

    /** Visit this X during a depth-first search of the forward dependency graph.
     */
    public X\s forwardVisit(X\s result) {
      if (!this.visited) {
        this.visited = true;
        return new X\s(this, X\s.searchForward(this.callees, result));
      }
      return result;
    }
  }
}

/*@
We can begin to understand how this code contributes to the calculation of
strongly-connected components by noting that a call to @forwardVisit()@ on a
binding $b$ that has not previously been visited will vist every binding in
the same strongly connected component as @b@, as well as all of the bindings
in groups that @b@ depends on (unless those binding groups have already been
visited).  Note also that @b@ will be the last of all those bindings that we
finish visiting, and hence will appear before all of those bindings in the
@result@ list.  Later, when we traverse the transpose/reverse dependency
graph, we will still have the same strongly connected components, but the
edges between components will be reversed.  Hence the result of the second
depth-first search will be a depth-first forest in which each tree
corresponds directly to a strongly-connected component of the original
graph.

%------------------------------------------------------------------------------
\subsection{Representing Binding SCCs}\label{sec-groups}
Before we complete the description of our dependency analysis
algorithm, we will describe how values of type @BindingSCC@
are used to represent individual binding groups.  Of course,
each @BindingSCC@ is associated with a particular list of
@bindings@.  The @bindings@ field in each @BindingSCC@ is
initially @null@; individual bindings can be added as the group
is constructed by calling @BindingSCC.add@.

@*/
macro SCCs(X) {
  public class X\SCC {
    /** Records the list of X\s in this binding group.
     */
    private X\s bindings = null;

    /** Return the list of X\s in this scc.
     */
    public getter bindings;

    /** Add an X to this scc.
     */
    public void add(X binding) {
      bindings = new X\s(binding, bindings);
    }
  }

/*@
In later stages of a compiler, it can be useful to know whether the
bindings in a particular binding scc are recursive; this can be
captured by including a @recursive@ flag in each @X\SCC@.
This flag will be initialized to @false@, but set to @true@ (by
calling @X\SCC.setRecursive@) if recursion is detected during
the second depth-first search of our dependency analysis algorithm.

@*/
  class X\SCC {
    /** Indicates if the bindings in this scc are recursive.  This flag is
     *  initialized to false but will be set to true if recursive bindings are
     *  discovered during dependency analysis.  If there are multiple bindings
     *  in this scc, then they must be mutually recursive (otherwise they would
     *  have been placed in different binding sccs) and this flag will be set to true.
     */
    private boolean recursive = false;

    /** This method is called when a recursive binding is
     *  discovered during dependency analysis.
     */
    public void setRecursive() {
      recursive = true;
    }

    /** Return a boolean true if this is a recursive binding scc.
     */
    public boolean isRecursive() {
      return recursive;
    }
  }

/*@
Again, for the purposes of later stages of the compiler, we will also record
dependency information between binding sccs.  For simplicity, we will store
only forward dependency information between binding sccs.  Of course, it
would be easy enough to add reverse dependency information too, if that was
needed.  Just as we used a type @X\s@ to represent lists of @X@ values, we
will introduce a type @X\SCCs@ to represent lists of @X\SCC@ values.

@*/
  macro List(X\SCC)
//macro addIsIn(X\SCC)  // TODO: should use this instead of find!
  public class X\SCCs   // make the SCCs class public.  TODO: Make this neater!

/*@
Not surprisingly, the code that we need to record dependency information for
each @X\SCC@ is much like the code that we used to record similar information
for @X\s@ in Section~\ref{sec-graph}.

@*/
  public class X\SCC {
    /** A list of the binding sccs on which this scc depends.  (This particular scc
     *  will not be included, so the graph of XSCCs will not have any cycles in it.)
     */
    private X\SCCs dependsOn = null;
    public getter dependsOn;

    /** Record a dependency between two binding sccs, avoiding
     *  self references and duplicate entries.
     */
    public static void addDependency(X\SCC from, X\SCC to) {
      if (from!=to && !find(to, from.dependsOn)) {
        from.dependsOn = new X\SCCs(to, from.dependsOn);
      }
    }

    /** Search for a specific binding scc within a given list.
     */
    public static boolean find(X\SCC scc, X\SCCs sccs) {
      for (; sccs!=null; sccs=sccs.next) {
        if (sccs.head==scc) {
            return true;
        }
      }
      return false;
    }
  }

}  // End of SCCs macro

/*@
%------------------------------------------------------------------------------
\subsection{The Reverse Depth-First Search}\label{sec-reverse}
To complete the calculation of strongly connected components, a second
depth-first search is used, this time over the reverse dependency graph.
The following definition of @Xs.searchReverse@ scans over the list
of bindings produced by the first search.  Each time it finds an unvisited
binding it creates a new @XSCC@, @scc@, and then
traverses the unvisited portion of the graph that can be reached from
@root@.  Each unvisited binding that is encountered during this traversal
is added to the new @scc@.  If we encounter a previously visited node
with the same @scc@ field, then we can be sure that this binding scc
is recursive.  Otherwise, we have found a previously detected binding
scc that depends on this @scc@ and we will update its dependency
information accordingly.

@*/
macro SCCReverseDFS(X) {
  class X\s {
    /** Depth-first search the reverse dependency graph, using the list
     *  of bindings that was obtained in the forward search, with the
     *  latest finishers first.
     */
    public static X\SCCs searchReverse(X\s xs) {
      X\SCCs sccs = null;
      for (; xs!=null; xs=xs.next) {
        if (xs.head.getScc()==null) {
          X\SCC scc = new X\SCC();
          sccs      = new X\SCCs(scc, sccs);
          xs.head.reverseVisit(scc);
        }
      }
      return sccs;
    }
  }

  class X {
    /** Records the binding scc in which this binding has been placed.
     *  This field is initialized to null but is set to the appropriate
     *  binding scc during dependency analysis.
     */
    private X\SCC scc = null;

    /** Return the binding scc that contains this binding.
     */
    public getter scc;

    /** Visit this binding during a depth-first search of the reverse
     *  dependency graph.  The scc parameter is the binding scc in
     *  which all unvisited bindings that we find should be placed. 
     */
    public void reverseVisit(X\SCC scc) {
      if (this.scc==null) {
        // If we arrive at a binding that hasn't been allocated to any SCC,
        // then we should put it in this SCC.
        this.scc = scc;
        scc.add(this);
        for (X\s callers=this.callers; callers!=null; callers=callers.next) {
          callers.head.reverseVisit(scc);
        }
      } else if (this.scc==scc) {
        // If we arrive at a binding that has the same binding scc
        // as the one we're building, then we know that it is recursive.
        scc.setRecursive();
        return;
      } else {
        // The only remaining possibility is that we've strayed outside
        // the binding scc we're building to a scc that *depends on*
        // the one we're building.  In other words, we've found a binding
        // scc dependency from this.scc to scc.
        X\SCC.addDependency(this.scc, scc);
      }
    }
  }
}

/*@
%------------------------------------------------------------------------------
\subsection{Putting it All Together}

The complete algorithm is captured by the following definition:

@*/
macro SCC(X) {
  macro SCCLists(X)
  macro SCCForwardDFS(X)
  macro SCCs(X)
  macro SCCReverseDFS(X)

  class X\s {
    /** Calculate the strongly connected components of a list of Xs that
     *  have been augmented with dependency information.
     */
    public static X\SCCs scc(X\s xs) {
/*
      // Compute the transpose (i.e., fill in the callers fields)
      for (X\s bs=xs; bs!=null; bs=bs.next) {
        for (X\s cs=bs.head.callees; cs!=null; cs=cs.next) {
          cs.head.callers = new X\s(bs.head, cs.head.callers);
        }
      }

      debug.Log.println("Beginning SCC algorithm");
      for (X\s bs=xs; bs!=null; bs=bs.next) {
        debug.Log.print(bs.head.getId() + ": callees {");
        String punc = "";
        for (X\s cs = bs.head.callees; cs!=null; cs=cs.next) {
          debug.Log.print(punc);
          punc = ", ";
          debug.Log.print(cs.head.getId());
        }
        debug.Log.print("}, callers {");
        punc = "";
        for (X\s cs = bs.head.callers; cs!=null; cs=cs.next) {
          debug.Log.print(punc);
          punc = ", ";
          debug.Log.print(cs.head.getId());
        }
        debug.Log.println("}");
      }
*/

      // Run the two depth-first searches of the main algorithm.
      return searchReverse(searchForward(xs, null));
    }
  }
}

macro DebugSCC(X) {
  class X\SCCs {
    import debug.Log;
    public static void display(String label, X\SCCs sccs) {
      Log.println(label + ": [");
      for (; sccs!=null; sccs=sccs.next) {
        X\SCC scc = sccs.head;
        Log.print("  ");
        Log.print(scc.isRecursive() ? "rec" : "nonrec");
        Log.print(" {");
        String punc = "";
        for (X\s bs=scc.getBindings(); bs!=null; bs=bs.next) {
          Log.print(punc); punc=", ";
          Log.print(bs.head.getId());
        }
        Log.println("}");
      }
      Log.println("]");
    }
  }
}

/*@
%------------------------------------------------------------------------------
\subsection{Tracking Dependencies}

@*/
macro Deps(X) {
  public class X\Deps {
    private X\s deps = null;

    /** Register a dependency on the specified variable.
     */
    public void addDependency(X x) {
      if (!X\s.isIn(x, deps)) {
        deps = new X\s(x, deps);
      }
    }

    public X\s extractFrom(X\s bound) {
      X\s prev = null;   // pointer to previous elem in list
      X\s exts = null;   // pointer to result list
      X\s ds   = deps;
      while (ds!=null) {
        if (X\s.isIn(ds.head, bound)) {
          X\s temp = ds.next;
          ds.next  = exts;
          exts     = ds;
          ds       = temp;
          if (prev==null) {
            deps = temp;
          } else {
            prev.next = temp;
          }
        } else {
          prev = ds;
          ds   = ds.next;
        }
      }
      return exts;
    }
  }

  // The code above requires a test for membership in X\s:
  macro AddIsIn(X)
}

